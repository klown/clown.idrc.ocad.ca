<!DOCTYPE HTML PUBLIC "-//SoftQuad//DTD draft HTML 3.2 + extensions for HoTMetaL PRO 3.0 19960802//EN" "hmpro3.dtd"><HTML><HEAD><TITLE>Audio Look and Feel Phase II:  FileChooser</TITLE></HEAD><BODY><H1>Audio Look and Feel Phase II:  FileChooser</H1><H2>Introduction</H2><P>This document represents an attempt at describing &quot;file choosing&quot;from a task based point of view.  &quot;File choosing&quot; is the act of eitherchoosing a file to open, or creating a new file for saving; in GUI terms, thisact involves interacting with a &quot;save-&quot; or &quot;get-file&quot;dialogue.</P><P>The point of this exercise is to show what a task based analysis is like inthe small.   It is ultimately desirable to perform such an analysis for anapplication as a whole.  However, that is a more complex problem.  File chooserdialogues are, in a sense, mini-applications with a small set of functions. Providing a task based description of them should give a feel for how task baseddescriptions could be done in general.</P><H2>Two Main Tasks</H2><P>File Choosers are invoked for two purposes.  To load, or &quot;open&quot; afile; and to save a file.  Which function a user desires to perform could beinvoked via:</P><UL><LI>Load document, &quot;or&quot;</LI><LI>Save document.</LI></UL><P>It is not entirely clear which object would respond to these commands.  Atthe time they are spoken, the file chooser itself is probably non-existent, andwould be built as a result of these commands.  There is a slight chance that aminimal chooser object exists in some thread whose purpose is to listen forthese commands, and then blossom into a full dialogue upon hearing them.  It ismore probable that some part of the application object would respond to thesecommands, and invoke the appropriate chooser.</P><P>Once the chooser dialogue is &quot;up&quot;, then the following funtionswould be available.</P><H2>Tasks of the Chooser Proper</H2><P>The hierarchy of tasks is fairly flat, meaning the tree of functionalitydoes not go very deep.  Furthermore, the tasks are common for the most partbetween a save dialogue vs. an &quot;open&quot; dialogue.</P><H3>Volumes</H3><P>At any given time, users are looking at the documents on a specific volume. A volume is usually a disk, but need not be -- the same disk may be partitionedinto multiple volumes, for example.  In addition, network servers and CD-ROMdisks may be represented as volumes on the desktop.  There are a number of tasksthat users will want to preform relevant to volumes.</P><DL><DT>Tell me the current volume</DT><DD>This would name the current default volume.</DD><DT>List volumes</DT><DD>This would recite the currently available volumes, as well as specify whichis current.  Possible options here include the order in which the volumes arelisted (alphabetic, space remaining, local vs. network, ejectable, etc.).</DD><DT>List current volume properties</DT><DD>Examples:  capacity, local vs. network, ejectable.</DD><DT>Change volume to &lt;name&gt;</DT><DD>Switch the current volume to the one named.  As a side effect, the current(default) directory changes.  How?  One possibility is to track where the userwas last time they were on this volume, and return to that directory first. Another possibility is to go to the root directory of the volume.</DD></DL><H3>Directories and files</H3><P>The next level down deals with directories.  The user has decided tonavigate a specific volume; from then on they are &quot;in&quot; some directoryor other.  They desire to know about the files and directories therein.</P><DL><DT>Tell me the current directory</DT><DD>This would name the current default volume.</DD><DT>List files</DT><DD>This would recite the contents of the current directory.  Possible optionshere include the order in which the volumes are listed (alphabetic, size offile, file type, etc.), and various filters (list text files only,sub-directories only, html files, etc.).  A related sub-command would be to listthe files one at a time via <STRONG>List next file</STRONG> and <STRONG>Listprevious file</STRONG>.  In this case, the system needs to keep track of thecurrent file.</DD><DT>List current directory properties</DT><DD>Examples:  number of files, number of sub-directories, parent directory.</DD><DT>Change directory to &lt;name&gt;</DT><DD>Switch the current direcotory to the one named.  The directory to switch tomust either be a sub-directory of the current directory, or the currentdirectory's parent.</DD><DT>Open file &lt;name&gt;</DT><DD>Open the file named.  Note that this has the side of effect of dismissingthe file chooser operation if the file is sucessfully opened.</DD><DT>Add file &lt;name&gt; to selection</DT><DD>This kind of file allows for the user to select a number of files uponwhich some common operation may subsequently occur, e.g., delete the selectedfiles.</DD><DT>List selected files</DT><DD>Name the files in the selection set.  Allow for exploration of theselections independent of the file list iteself?</DD><DT>Delete file &lt;name&gt;</DT><DD>Delete the file so named.  Note that although most gui file choosers do nothave this functionality, in an audio interface, this would be a good place toput it.  It should probably be followed by a confirmation of some kind.  Also,successful deletion should not dismiss the dialogue. </DD></DL><H4>Save File Commands</H4><DL><DT>Create new directory</DT><DD>This would create a new sub-directory within the current directory.  A namemust be provided.</DD><DT>New file name is &lt;name&gt;</DT><DD>Provides a name for the file to be saved.</DD></DL><P>One of the next questions to answer is what, in Java, resembles this model? What is the Apple Event analogue in Java?  What facilities does Java have thatpublishes functionality and allows for external control?  The only thing thatimmediately comes to mind is Java Beans.  Unfortunately, my knowledge of JavaBeans is relatively weak.  I would have to read up on the subject before sayingunequivocally that this is the way to go.  Nonetheless, it seems to me that away to implement the above model is to create a Java Bean that is the task-baseddescription of a Java application.  That bean acts as an intermediary betweenthe user and a target application.  It  would know how to translate the incomingcommands/messages into sequence of calls to the relevant GUI widgets thatactually implement the application functionality.  In some sense the bean wouldcontain a script that fired when it received a command.</P><P>There is one other aspect of Java, specifically Swing, that needs furtherstudy.  This is the defunct target manager.  The reason that it is defunct isthat the Swing team did not have the time to finish it, but they may go back andrevisit it.  Versions of the target manager did appear in early releases ofSwing such as the 0.x versions.</P><P>The target manager was a way of decoupling functionality from the userinterface.  The target manager kept a large table of all the action's that agiven application could execute.  The developer was then required to specifywhich GUI widgets were the target of these actions.  To use a standard example,the developer would register a &quot;cut&quot; action with the target manager. Later, when creating a &quot;cut&quot; menu item, or a &quot;cut&quot; tool barbutton, the developer would ask the target manager to associate these GUIwidgets be with the &quot;cut&quot; action.</P><P>The important point about the target manager, if I understand it correctly,is that it allows one to address the application via its actions directly, andfrom the actions, determine which GUI components execute them.  From a &quot;speechacts&quot; point of view, asking a target manager what those GUI components areis irrelevant.  What you want are the actions themselves, and if you can getthem, you might be able to avoid &quot;scripting the GUI elements&quot;.</P><P>Now I have oodles of questions about the target manager.  How was itorganized (flat or hierarchical)?  How were the actions described?  Once youacquire a reference to an action, can you really tell what it will do?  Will itbe necessary to chain a set of actions together to achieve some functionality? Do the actions provide any feedback in terms of &quot;results&quot;, so theaudio interface can inform the user what is happening?  I hope to go back tothose earlier versions of swing and see what the capabilities of the targetmanager were. </P><H2>Other Issues</H2><P>When talking with Jutta about this, she said she was aware ofapproaches/studies concerning how to create hierarchical models of applications. I briefly touched on this above with the mail program example.  At the toplevel, you can either ask go to you inbox, or compose a message.  Once at thelevel of the inbox, there are another set of tasks that you can do.  Some tasksat a given level take to you to another level with its own tasks.   I want tounderstand this kind of analysis better.  How do you do it?  What do you lookfor?</P><P>And then there's Allen's &quot;cottage industry&quot;.  In this scenario,the ATRC acts as a consultant.  We advertise ourselves as expert applicationanalyzers -- &quot;give us you applications and we will generate a task baseddescription of them&quot;.  (It would be nice if this could be partly automated-- is this even a possibility?)  This somehow connects with Jutta's hierarchicalanalysis.  And it somehow fits with a device (a Java Bean?) that captures thedescription, tells other applications how to call it, and relays that to theactual target application that one desires to run.  Lots to investigate; lots tothink about.</P><H2>What's Right about the Audio Laf?</H2><P>Having dissed our audio laf, I feel I should put at least one good word infor it still.  I have the sneaking suspicion even if we go to all the trouble ofanalyzing an application and setting up a model of its functionality, there willstill be some functionality that we have missed.  In that case, we will have toallow the user to speak something like the following to walk the menu system:</P><OL><LI>Go to the menu bar. [&quot;Menu Bar&quot;]</LI><LI>Go down.  [&quot;File&quot;]</LI><LI>Next. [&quot;Edit&quot;]</LI><LI>Next. [&quot;View&quot;]</LI><LI>Go down.  [&quot;Hide Navigator Tool Bar&quot;]</LI><LI>Next.  [&quot;Hide Location Tool Bar&quot;]</LI><LI>Next.  [&quot;Reload&quot;]</LI><LI>Next.  [&quot;Show Images&quot;]</LI><LI>Next.  [&quot;Stop Loading&quot;]</LI><LI>Next.  [&quot;Page Source&quot;]</LI><LI>Next.  [&quot;Page Info&quot;]</LI><LI>Select Page Info.</LI></OL><P>Now, there may be ways to speed this up (a vocal version of our first keynavigation technique), but it will still have to be there for functionality thatwe have have &quot;missed&quot;.</P></BODY></HTML>